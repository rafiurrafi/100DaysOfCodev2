<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Image Path Generator</title>
  </head>
  <body>
    <style>
      .copy-me-container {
        position: relative;
      }
      .copy-me {
        max-width: 50px;
        padding: 15px;
        position: absolute;
        border: 1px solid tomato;
      }
      .clone {
        color: white;
      }
      .garbage {
        position: absolute;
        bottom: 1rem;
        right: 1rem;
        height: 100px;
        width: 100px;
        background-color: black;
      }
    </style>
    <h3>Sweet Helena, Make me Immortal with a KISSðŸ’ž</h3>
    <div class="copy-me-container">
      <div class="copy-me">You</div>
      <div class="copy-me">Should</div>
      <div class="copy-me">Not</div>
      <div class="copy-me">Trust</div>
      <div class="copy-me">Anyone</div>
    </div>
    <div class="garbage"></div>

    <script>
      const copyMeItems = document.querySelectorAll(".copy-me");
      const holder = {};

      copyMeItems.forEach((item, index) => {
        item.style.left = index * 75 + "px";

        item.addEventListener("click", (e) => {
          holder.obj = item.cloneNode(true);

          // holder.obj.style.left = item.offsetLeft + "px";
          // holder.obj.style.top = item.offsetTop + "px";

          holder.obj.startY = item.offsetTop;
          holder.obj.startX = item.offsetLeft;

          holder.obj.style.backgroundColor = "red";
          holder.obj.style.cursor = "move";
          holder.obj.classList.add("clone");

          holder.obj.moves = Math.floor(Math.random() * 25);
          holder.obj.int = setInterval(mover, 25);

          function mover() {
            if (holder.obj.moves <= 0) clearInterval(holder.obj.int);
            else {
              holder.obj.moves--;
              holder.obj.startY += 10;
              holder.obj.startX += 1;

              holder.obj.style.left = holder.obj.startX + "px";
              holder.obj.style.top = holder.obj.startY + "px";
            }
          }

          dragger(holder.obj);
          document.body.appendChild(holder.obj);
        });
      });
      function dragger(element) {
        let pos = {};
        element.onmousedown = dragMouse;
        function dragMouse(e) {
          pos.x = e.clientX;
          pos.y = e.clientY;
          document.onmouseup = function () {
            document.onmouseup = null;
            document.onmousemove = null;
          };
          document.onmousemove = function (e) {
            if (isColide(element)) console.log("Over");
            else console.log("ok");

            pos.updatedX = pos.x - e.clientX;
            pos.updatedY = pos.y - e.clientY;

            pos.x = e.clientX;
            pos.y = e.clientY;

            element.style.left = element.offsetLeft - pos.updatedX + "px";
            element.style.top = element.offsetTop - pos.updatedY + "px";
          };
        }
      }
      function isColide(a) {
        const garbage = document.querySelector(".garbage");
        const aBoundary = a.getBoundingClientRect();
        const bBoundary = garbage.getBoundingClientRect();

        console.log(aBoundary.right, bBoundary.left);

        return !(
          aBoundary.left < bBoundary.right ||
          aBoundary.bottom > bBoundary.top ||
          aBoundary.top < bBoundary.bottom ||
          aBoundary.right > bBoundary.left
        );
      }
      // const rep = document.querySelectorAll(".copy-me");
      // const garbage = document.querySelector(".garbage");

      // let holder = {};

      // rep.forEach((element, index) => {
      //   element.style.left = index * 100 + "px";
      //   //add click handler
      //   element.addEventListener("click", (e) => {
      //     holder.obj = element.cloneNode(true);
      //     holder.obj.classList.add("clone-div");

      //     holder.obj.style.cursor = "move";
      //     holder.obj.style.backgroundColor = getColor();

      //     holder.obj.startY = element.offsetTop;
      //     holder.obj.startX = element.offsetLeft;

      //     holder.obj.moves = Math.floor(Math.random() * 25);
      //     holder.obj.int = setInterval(mover, 25);

      //     function mover() {
      //       if (holder.obj.moves < 0) clearInterval(holder.obj.int);
      //       else {
      //         holder.obj.moves--;
      //         holder.obj.startY += 10;
      //         holder.obj.startX += 1;
      //         holder.obj.style.left = holder.obj.startX + "px";
      //         holder.obj.style.top = holder.obj.startY + "px";
      //       }
      //     }

      //     dragger(holder.obj);
      //     document.body.appendChild(holder.obj);
      //   });
      // });

      // function dragger(element) {
      //   let pos = {};
      //   element.onmousedown = dragMouse;

      //   function dragMouse(e) {
      //     pos.horizontal = e.clientX;
      //     pos.vertical = e.clientY;

      //     if (isCollide(element)) {
      //       console.log("over");
      //     } else {
      //       console.log("ok");
      //     }

      //     document.onmouseup = function () {
      //       document.onmouseup = null;
      //       document.onmousemove = null;
      //     };
      //     document.onmousemove = function (e) {
      //       if (isCollide(element)) {
      //         element.onmousedown = null;
      //         element.parentElement.removeChild(element);
      //       } else {
      //         console.log("ok");
      //       }

      //       pos.updatedHorizontal = pos.horizontal - e.clientX;
      //       pos.updatedVertical = pos.vertical - e.clientY;

      //       pos.horizontal = e.clientX;
      //       pos.vertical = e.clientY;

      //       element.style.left =
      //         element.offsetLeft - pos.updatedHorizontal + "px";
      //       element.style.top = element.offsetTop - pos.updatedVertical + "px";
      //     };
      //   }
      // }

      // function getColor() {
      //   const c = () => {
      //     let hex = Math.floor(Math.random() * 256).toString(16);
      //     hex = ("0" + String(hex)).substr(-2);
      //     return hex;
      //   };
      //   return "#" + c() + c() + c();
      // }
      // function isCollide(element) {
      //   const elementArea = element.getBoundingClientRect();
      //   const garbageArea = garbage.getBoundingClientRect();
      //   return !(
      //     elementArea.right < garbageArea.left ||
      //     elementArea.top > garbageArea.bottom ||
      //     elementArea.bottom < garbageArea.top ||
      //     elementArea.left > garbageArea.right
      //   );
      // }
    </script>
  </body>
</html>
